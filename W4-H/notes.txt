 Dear All,

 This week we had a wrap-up of the C portion of the course - we did a
couple of exercises with pointers and strings (basically showing how to
pass an array into a function that needs to change its contents, both
using array notation, and using pointer notation).

 At this point the students should be comfortable with the basic C
programming concepts:

 - Variables and types
 - Program structure
 - Functions, arguments, and return values
 - Arrays and strings
 - Pointers
 - Pointer arithmetic for accessing information

 And they should be able to use the memory model to show you what's
happening when you declare and manipulate some variables. That means

 - If you show them snippets of code with function declarations and
variables they should be able to tell you how many boxes will be reserved
in memory, and what those boxes (name and type) should be
 - They should be able to tell you that boxes reserved for a function are
released once the function returns
 - They should be able to show you on the memory diagram what the contents
of those boxes are if you run a few lines of code that change the values
of the variables, or call a function, etc.

 This coming week we'll start talking about A48 material proper:
Containers, collections, compound data types, and lists.

 For this week's tutorial, I thought you would enjoy teaching a bit :) so,
your material is as follows:

_____

 Topic: How data is stored and represented in a computer's memory
 Motivation: They were confused and somewhat surprised that characters have
             a numeric value, and you can think of them as just an
             integer to which you can add, subtract, or otherwise
             manipulate.

 Key idea: *ASK THEM* how information is stored in a computer's memory
            Hear them out, hopefully someone will mention bits

            Point out everything in a digital computer is eventually reduced
            to a bunch of bits, reasons for that include:
            - Easy to represent using electric signals, or voltage values,
              or magnetic orientation, or presence/absence of a hole in a
              disc's surface
            - Can represent EVERYTHING using a sufficiently long string of
              bits and a clever encoding

 So the trick is to figure out, for any type of data we wish to store, how
to encode it into a sequence of bits that *uniquely* represents each
individual value or data may take.

 First show them how we can store a regular decimal number using binary

 bits               decimal #
 0000                   0
 0001                   1
 0010                   2          * Do up to 4, then have them
 0011                   3            figure out what follows, they
 0100                   4            need to see the pattern here,
 0101                   5            And don't start with 'powers of 2'.
 0110                   6            Once they figure out the pattern
 0111                   7            and complete the table up to 15,
 1000                   8            then you can say, larger numbers
 .                                   work the same way with more bits
 .                                   - Leave the powers of 2 discussion
 .                                     for B58, it's a full hour! you
 etc.                                  are just introducing an idea here!

 Characters in text:

 character             How it's encoded
                       as a number                      Binary equivalent

    'A'                ASCII Table, lists                    1000001
                       for each character that
                       can appear in text, a
                       unique, corresponding
                       integer number
                             A = 65
                             B = 66
                             etc.
                       There are 255 characters
                       we can encode in ASCII,
                       the value of 0 is reserved
                       for the end-of-string
                       delimiter
                       '\0' =  0

  What happened?
  - We created a table that translates each character in text to an
    integer, that integer can be converted to bits as we saw a moment
    ago

  So text -> integers -> binary - and we can store each character in
  a computer's memory as a sequence of bits :)

  Each character uses 8 bits = 1 byte, that's by definition, and has no
particular significance other than that is what people thought would be
enough for standard text!

 Other data types:

 Float                  Encoding

 3.141592               Use scientific notation
                        3.141592 = .3141592 * 10^1
                        (try it out! :) )

                        Separately encode
                        - 3141592 as an integer, then
                        convert to bits
                        - The power of 10 (in this case
                          1  ) as an integer, converted
                          to bits

                        Store the bit strings for the
                        'mantissa' and the exponent.

                        Another example

                        25.5  =  .255 * 10^2
                        (have them check this out)

                        So store 255 as an integer in binary
                        and the exponent: 2, also in binary

                        There are international standards that
                        specify how many bits to use for the
                        mantissa and exponent, you'll see all
                        of that in B58!

  Images!

  Each image is made up of pixels, let's start with a grayscale
  image

  Each pixel is storing a brightness value

  Pixel               Conversion table                Binary

  white               White = 255                     255 = 11111111
                      Black = 0
                      Values between 0 and 255
                      encode shades of gray
                      from almost black to
                      almost white

  So for each pixel, use 1-byte (8 bits) to encode the brightness value.
  For colour images, encode separately the brightness value for each of 3
colours R, G, B. Each pixel then uses 3 bytes (24 bits) to encode the
corresponding color as a unique RGB triplet.

  Sound recordings

  Sound Volume               Encoding

  A floating point           Encoded as a float :)
  number from -1 to +1       Or you can convert it
                             to integers in [-127 to
                             +127] and encode it as
                             an integer.
                             There are multiple existing
                             encodings, but the point is
                             it is just a number, we can
                             convert this to binary

  Computer code

  C instruction     Equivalent CPU instructions        Encoding
                         (MIPS 32)
  x=x+1;                 LW $t1,x                      Each CPU instruction
                         ADDI $t1, $t1, 1              has a unique integer
                         SW $t1,x                      ID - encode that
                                                       in binary
                                                       - Each CPU register
                    (loads the value of x into         has a unique integer
                     into a CPU register called t1,    ID, encode it in
                     adds 1 to the value in this       binary.
                     register, leaving the result      - Arguments are
                     also in t1, then stores the       either numbers (we
                     resulting value back into         can encode them in
                     the locker where x is stored)     binary), or memory
                     * When you compile your C code    addresses, which are
                       the compiler does this          also numbers we can
                       translation!                    encode in binary.

 So CPU instructions become

     ADDI               $t1           $t1            1
 Instruction ID      Register ID    Register ID    Argument

      05                01             01            1
 In bits:
      1001              001            001          001

 (Those are made up instruction IDs and register IDs! just to give an
example, the actual IDs can be found in a technical manual for each CPU).

 Bottom line:

 EVERYTHING we store in a computer: Text, numbers, images, sound, video,
and computer code, gets translated into a corresponding, unique sequence
of bits, and stored in memory.


 SO:

  If we just go poking into memory, and we don't know what kind of
information is supposed to be stored there, what happens???

  Or what is the same: Can we figure out what some bit values we found in
memory are supposed to represent?

 * See what they say here!! and dig into their answers until, hopefully,
everyone is confused.

 Now, let's have some fun:

 #include<stdio.h>
 #include<stdlib.h>
 int main()
 {
    char  stringy[7]="Logic!";
    char *c;
    int *i;
    float *f;

    printf("My string says: %s\n",stringy);

    // Let's get a pointer to the string!
    c=&stringy[0];
    i=&stringy[0];
    f=&stringy[0];

    printf("Wait a sec, is it really a string?\n");
    printf("I think it may be a char! %c\n",*c);
    printf("Or perhaps it's an int??? %d\n",*i);
    printf("Or maybe a float?? %f\n",*f);

    printf("This gets really weird!\n");
    *i=1768382797;
    printf("My string says: %s\n",stringy);
    printf("What just happened!!!????\n");
 }

 Put that in a program, compile/run it, and then *ask them to explain to
you what the heck just happened!*

 :)

 ____

 That'll keep you busy, send me any questions you have!

 MUSTAFA: Please don't post the tutorial material on your site until AFTER
the tutorials have taken place, if you post it early, people just skip
the tutorial, which is doofus but that's what they do.

 Thanks!

 P.
